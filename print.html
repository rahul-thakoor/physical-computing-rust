<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="step_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="step_2.html"><strong aria-hidden="true">2.</strong> What you will need</a></li><li><a href="step_3.html"><strong aria-hidden="true">3.</strong> GPIO pins</a></li><li><a href="step_4.html"><strong aria-hidden="true">4.</strong> Lighting an LED</a></li><li><a href="step_5.html"><strong aria-hidden="true">5.</strong> Switching an LED on and off</a></li><li><a href="step_6.html"><strong aria-hidden="true">6.</strong> Flashing an LED</a></li><li><a href="step_7.html"><strong aria-hidden="true">7.</strong> Using buttons to get input</a></li><li><a href="step_8.html"><strong aria-hidden="true">8.</strong> Manually controlling the LED</a></li><li><a href="step_9.html"><strong aria-hidden="true">9.</strong> Making a switch</a></li><li><a href="step_10.html"><strong aria-hidden="true">10.</strong> Using a buzzer</a></li><li><a href="step_11.html"><strong aria-hidden="true">11.</strong> Making traffic lights</a></li><li><a href="step_12.html"><strong aria-hidden="true">12.</strong> Using a light-dependent resistor</a></li><li><a href="step_13.html"><strong aria-hidden="true">13.</strong> Using a PIR sensor</a></li><li><a href="step_14.html"><strong aria-hidden="true">14.</strong> Using an ultrasonic distance sensor</a></li><li><a href="step_15.html"><strong aria-hidden="true">15.</strong> Analogue inputs</a></li><li><a href="step_16.html"><strong aria-hidden="true">16.</strong> Using motors</a></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#introduction" id="introduction"><h2>Introduction</h2></a>
<a class="header" href="print.html#what-you-will-do" id="what-you-will-do"><h3>What you will do</h3></a>
<p>Learn how to use the GPIO pins on your Raspberry Pi to interface with electronic components, such as LEDs and PIRs.</p>
<a class="header" href="print.html#what-you-will-learn" id="what-you-will-learn"><h3>What you will learn</h3></a>
<p>This resource covers elements from the following strands of the <a href="https://www.raspberrypi.org/curriculum/">Raspberry Pi Digital Making Curriculum</a>{:target=&quot;_blank&quot;}:</p>
<ul>
<li><a href="https://www.raspberrypi.org/curriculum/programming/creator">Use basic programming constructs to create simple programs</a>{:target=&quot;_blank&quot;}</li>
<li><a href="https://www.raspberrypi.org/curriculum/physical-computing/creator">Use basic digital, analogue, and electromechanical components</a>{:target=&quot;_blank&quot;}</li>
</ul>
<a class="header" href="print.html#what-you-will-need" id="what-you-will-need"><h2>What you will need</h2></a>
<a class="header" href="print.html#hardware" id="hardware"><h3>Hardware</h3></a>
<p>As well as a Raspberry Pi with an SD card and the usual peripherals, you'll also need:</p>
<table><thead><tr><th align="center">1x Solderless breadboard </th><th align="center"> Male-to-female jumper leads </th><th align="center"> Female-to-female jumper leads </th><th align="center"> Male-to-male jumper leads </th></tr></thead><tbody>
<tr><td align="center"> <img src="images/breadboard.png" alt="breadboard" /> </td><td align="center"> <img src="images/jumper-male-to-female.png" alt="m to f jumper leads" /> </td><td align="center"> <img src="images/jumper-female-to-female.png" alt="f to f jumper leads" /> </td><td align="center"> <img src="images/jumper-male-to-male.png" alt="m to m jumper leads" /> </td></tr>
</tbody></table>
<table><thead><tr><th> 1x Tactile button </th><th> 3x LEDs </th><th> Ultrasonic distance sensor</th><th> Passive infrared motion sensor </th></tr></thead><tbody>
<tr><td align="center"> <img src="images/tactile-push-button.png" alt="tactile button" /> </td><td align="center"> <img src="images/led.png" alt="LED" /> </td><td align="center"> <img src="images/ultrasonic-distance-sensor.png" alt="ultrasonic distance sensor" /> </td><td align="center"> <img src="images/pir.png" alt="PIR sensor" /> </td></tr>
</tbody></table>
<table><thead><tr><th> Light Dependent Resistor </th><th> 2x 5V Micro Metal Gearmotor </th><th> 3x 330Ω Resistor</th><th> 470Ω Resistor </th></tr></thead><tbody>
<tr><td align="center"> <img src="images/ldr.png" alt="LDR" /> </td><td align="center"> <img src="images/motor.png" alt="motor" /> </td><td align="center"> <img src="images/resistor-330r.png" alt="330 resistor" /> </td><td align="center"> <img src="images/resistor-470r.png" alt="470 resistor" /> </td></tr>
</tbody></table>
<table><thead><tr><th> 1x 1μF Capacitor </th><th> Buzzer </th><th> Motor Controller </th><th> Battery Pack </th></tr></thead><tbody>
<tr><td align="center"> <img src="images/capacitor.png" alt="capacitor" /> </td><td align="center"> <img src="images/piezo-buzzer.png" alt="buzzer" /> </td><td align="center"> <img src="images/motor-controller.png" alt="motor controller" /> </td><td align="center"> <img src="images/battery-pack.png" alt="battery pack" /> </td></tr>
</tbody></table>
<a class="header" href="print.html#software" id="software"><h3>Software</h3></a>
<p>There are no additional software requirements for this resource beyond what is pre-installed in the current Raspbian image. To make sure your SD card is up-to-date, see the <a href="https://www.raspberrypi.org/documentation/raspbian/updating.md">updating Raspbian guide</a>{:target=&quot;_blank&quot;}.</p>
<a class="header" href="print.html#gpio-pins" id="gpio-pins"><h2>GPIO pins</h2></a>
<p>One powerful feature of the Raspberry Pi is the row of GPIO pins along the top edge of the board. GPIO stands for General-Purpose Input/Output. These pins are a physical interface between the Raspberry Pi and the outside world. At the simplest level, you can think of them as switches that you can turn on or off (input) or that the Pi can turn on or off (output).</p>
<p>The GPIO pins allow the Raspberry Pi to control and monitor the outside world by being connected to electronic circuits. The Pi is able to control LEDs, turning them on or off, run motors, and many other things. It's also able to detect whether a switch has been pressed, the temperature, and light. We refer to this as physical computing.</p>
<p>There are 40 pins on the Raspberry Pi (26 pins on early models), and they provide various different functions.</p>
<p>If you have a RasPiO pin label, it can help to identify what each pin is used for. Make sure your pin label is placed with the keyring hole facing the USB ports, pointed outwards.</p>
<p><img src="images/raspio-ports.jpg" alt="" /></p>
<p>If you don't have a pin label, then this guide can help you to identify the pin numbers:</p>
<p><img src="images/pinout.png" alt="" /></p>
<p>You'll see pins labelled as 3V3, 5V, GND and GP2, GP3, etc:</p>
<table><thead><tr><th>   </th><th>   </th><th>   </th></tr></thead><tbody>
<tr><td> 3V3 </td><td> 3.3 volts </td><td> Anything connected to these pins will always get 3.3V of power </td></tr>
<tr><td> 5V </td><td> 5 volts </td><td> Anything connected to these pins will always get 5V of power </td></tr>
<tr><td> GND </td><td> ground </td><td> Zero volts, used to complete a circuit </td></tr>
<tr><td> GP2 </td><td> GPIO pin 2 </td><td> These pins are for general-purpose use and can be configured as input or output pins </td></tr>
<tr><td> ID_SC/ID_SD/DNC </td><td> Special purpose pins </td></tr>
<tr></tr>
</tbody></table>
<p><strong>WARNING</strong>: If you follow the instructions, then playing about with the GPIO pins is safe and fun. Randomly plugging wires and power sources into your Pi, however, may destroy it, especially if using the 5V pins. Bad things can also happen if you try to connect things to your Pi that use a lot of power; LEDs are fine, motors are not. If you're worried about this, then you might want to consider using an add-on board such as the <a href="https://shop.pimoroni.com/products/explorer-hat">Explorer HAT</a> until you're confident enough to use the GPIO directly.</p>
<a class="header" href="print.html#lighting-an-led" id="lighting-an-led"><h2>Lighting an LED</h2></a>
<p>LEDs are delicate little things. If you put too much current through them they will pop (sometimes quite spectacularly). To limit the current going through the LED, you should always use a resistor in series with it.</p>
<p>Try connecting the long leg of an LED to the Pi's 3V3 and the short leg to a GND pin. The resistor can be anything over about 50Ω.</p>
<p><img src="images/led-3v3.png" alt="" /></p>
<p>The LED should light up. It will always be on, because it's connected to a 3V3 pin, which is itself always on.</p>
<p>Now try moving it from 3V3 to GPIO pin 17:</p>
<p><img src="images/led-gpio17.png" alt="" /></p>
<p>The LED should now turn off, but now it's on a GPIO pin, and can therefore be controlled by code.</p>
<a class="header" href="print.html#switching-an-led-on-and-off" id="switching-an-led-on-and-off"><h2>Switching an LED on and off</h2></a>
<p>GPIO Zero is a new Python library which provides a simple interface to everyday GPIO components. It comes installed by default in Raspbian.</p>
<ul>
<li>Open IDLE.</li>
</ul>
<p>[[[rpi-gui-idle-opening]]]</p>
<ul>
<li>
<p>You can switch an LED on and off by typing commands directly into the Python interpreter window (also known as the Python <strong>shell</strong>). Let's do this by first importing the GPIO Zero library. You also need to tell the Pi which GPIO pin you are using - in this case pin 17. Next to the chevrons <code>&gt;&gt;&gt;</code>, type:</p>
<pre><code class="language-python">from gpiozero import LED
led = LED(17)
</code></pre>
<p>Press <strong>Enter</strong> on the keyboard.</p>
</li>
<li>
<p>To make the LED switch on, type the following and press <strong>Enter</strong>:</p>
<pre><code class="language-python">led.on()
</code></pre>
</li>
<li>
<p>To make it switch off you can type:</p>
<pre><code class="language-python">led.off()
</code></pre>
</li>
<li>
<p>Your LED should switch on and then off again. But that's not all you can do.</p>
</li>
</ul>
<a class="header" href="print.html#flashing-an-led" id="flashing-an-led"><h2>Flashing an LED</h2></a>
<p>With the help of the <code>time</code> library and a little loop, you can make the LED flash.</p>
<ul>
<li>
<p>Create a new file by clicking <strong>File &gt; New file</strong>.</p>
</li>
<li>
<p>Save the new file by clicking <strong>File &gt; Save</strong>. Save the file as <code>gpio_led.py</code>.</p>
</li>
<li>
<p>Enter the following code to get started:</p>
<pre><code class="language-python">from gpiozero import LED
from time import sleep

led = LED(17)

while True:
    led.on()
    sleep(1)
    led.off()
    sleep(1)
</code></pre>
</li>
<li>
<p>Save with <strong>Ctrl + S</strong> and run the code with <strong>F5</strong>.</p>
</li>
<li>
<p>The LED should be flashing on and off. To exit the program press <strong>Ctrl + C</strong> on your keyboard.</p>
</li>
</ul>
<a class="header" href="print.html#using-buttons-to-get-input" id="using-buttons-to-get-input"><h2>Using buttons to get input</h2></a>
<p>Now you're able to control an output component (an LED), let's connect and control an input component: a button.</p>
<ul>
<li>
<p>Connect a button to another GND pin and GPIO pin 2, like this:</p>
<p><img src="images/button.png" alt="" /></p>
</li>
<li>
<p>Create a new file by clicking <strong>File &gt; New file</strong>.</p>
</li>
<li>
<p>Save the new file by clicking <strong>File &gt; Save</strong>. Save the file as <code>gpio_button.py</code>.</p>
</li>
<li>
<p>This time you'll need the <code>Button</code> class, and to tell it that the button is on pin 2. Write the following code in your new file:</p>
<pre><code class="language-python">from gpiozero import Button
button = Button(2)
</code></pre>
</li>
<li>
<p>Now you can get your program to do something when the button is pushed. Add these lines:</p>
<pre><code class="language-python">button.wait_for_press()
print('You pushed me')
</code></pre>
</li>
<li>
<p>Save with <strong>Ctrl + S</strong> and run the code with <strong>F5</strong>.</p>
</li>
<li>
<p>Press the button and your text will appear.</p>
</li>
</ul>
<a class="header" href="print.html#manually-controlling-the-led" id="manually-controlling-the-led"><h2>Manually controlling the LED</h2></a>
<p>You can now combine your two programs written so far to control the LED using the button.</p>
<ul>
<li>
<p>Create a new file by clicking <strong>File &gt; New file</strong>.</p>
</li>
<li>
<p>Save the new file by clicking <strong>File &gt; Save</strong>. Save the file as <code>gpio_control.py</code>.</p>
</li>
<li>
<p>Now write the following code:</p>
<pre><code class="language-python">from gpiozero import LED, Button
from time import sleep

led = LED(17)
button = Button(2)

button.wait_for_press()
led.on()
sleep(3)
led.off()
</code></pre>
</li>
<li>
<p>Save and run your program. When you push the button the LED should come on for three seconds.</p>
</li>
</ul>
<a class="header" href="print.html#making-a-switch" id="making-a-switch"><h2>Making a switch</h2></a>
<p>With a switch, a single press and release on the button would turn the LED on, and another press and release would turn it off again.</p>
<ul>
<li>
<p>Modify your code so that it looks like this:</p>
<pre><code class="language-python">from gpiozero import LED, Button
from time import sleep

led = LED(17)
button = Button(2)

while True:
    button.wait_for_press()
    led.toggle()
    sleep(0.5)
</code></pre>
<p><code>led.toggle()</code> switches the state of the LED from on to off, or off to on. Since this happens in a loop the LED will turn on and off each time the button is pressed.</p>
</li>
<li>
<p>It would be great if you could make the LED switch on only when the button is being held down. With GPIO Zero, that's easy. There are two methods of the <code>Button</code> class called <code>when_pressed</code> and <code>when_released</code>. These don't block the flow of the program, so if they are placed in a loop, the program will continue to cycle indefinitely.</p>
</li>
<li>
<p>Modify your code to look like this:</p>
<pre><code class="language-python">from gpiozero import LED, Button
from signal import pause

led = LED(17)
button = Button(2)

button.when_pressed = led.on
button.when_released = led.off

pause()
</code></pre>
</li>
<li>
<p>Save and run the program. Now when the button is pressed, the LED will light up. It will turn off again when the button is released.</p>
</li>
</ul>
<a class="header" href="print.html#using-a-buzzer" id="using-a-buzzer"><h2>Using a buzzer</h2></a>
<p>There are two main types of buzzer: <em>active</em> and <em>passive</em>.</p>
<p>A <em>passive</em> buzzer emits a tone when a voltage is applied across it. It also requires a specific signal to generate a variety of tones. The <em>active</em> buzzers are a lot simpler to use, so these are covered here.</p>
<a class="header" href="print.html#connecting-a-buzzer" id="connecting-a-buzzer"><h3>Connecting a buzzer</h3></a>
<p>An <em>active</em> buzzer can be connected just like an LED, but as they are a little more robust, you won't be needing a resistor to protect them.</p>
<p>Set up the circuit as shown below:</p>
<p><img src="images/buzzer-circuit.png" alt="buzzer" /></p>
<ul>
<li>
<p>Add <code>Buzzer</code> to the <code>from gpiozero import...</code> line:</p>
<pre><code class="language-python">from gpiozero import Buzzer
from time import sleep
</code></pre>
</li>
<li>
<p>Add a line below your creation of <code>button</code> and <code>lights</code> to add a <code>Buzzer</code> object:</p>
<pre><code class="language-python">buzzer = Buzzer(17)
</code></pre>
</li>
<li>
<p>In GPIO Zero, a <code>Buzzer</code> works exactly like an <code>LED</code>, so try adding a <code>buzzer.on()</code> and <code>buzzer.off()</code> into your loop:</p>
<pre><code class="language-python">while True:
    buzzer.on()
    sleep(1)
    buzzer.off()
    sleep(1)

</code></pre>
</li>
<li>
<p>A <code>Buzzer</code> has a <code>beep()</code> method which works like an <code>LED</code>'s <code>blink</code>. Try it out:</p>
<pre><code class="language-python">while True:
    buzzer.beep()
</code></pre>
</li>
</ul>
<a class="header" href="print.html#making-traffic-lights" id="making-traffic-lights"><h2>Making traffic lights</h2></a>
<p>For this worksheet you'll need a breadboard, three LEDs, a button, a buzzer, and the necessary jumper cables and resistors. You can purchase these individually, or get everything you need in the <a href="https://thepihut.com/products/camjam-edukit">CamJam EduKit</a>.</p>
<a class="header" href="print.html#wiring" id="wiring"><h3>Wiring</h3></a>
<p>To get started, you'll need to place all the components on the breadboard and connect them to the appropriate GPIO pins on the Raspberry Pi.</p>
<ul>
<li>
<p>First, you need to understand how each component is connected:</p>
<ul>
<li>A push button requires 1 ground pin and 1 GPIO pin</li>
<li>An LED requires 1 ground pin and 1 GPIO pin, with a current limiting resistor</li>
<li>A buzzer requires 1 ground pin and 1 GPIO pin</li>
</ul>
<p>Each component requires its own individual GPIO pin, but components can share a ground pin. We will use the breadboard to enable this.</p>
</li>
<li>
<p>Place the components on the breadboard and connect them to the Raspberry Pi GPIO pins, according to the following diagram:</p>
<p><img src="images/camjam1wiring.png" alt="GPIO diagram" /></p>
<p>Note that the row along the long side of the breadboard is connected to a ground pin on the Raspberry Pi, so all the components in that row (which is used as a ground rail) are hence connected to ground.</p>
</li>
<li>
<p>Observe the following table, showing which GPIO pin each component is connected to:</p>
</li>
</ul>
<table><thead><tr><th> Component </th><th align="center"> GPIO pin </th></tr></thead><tbody>
<tr><td> Button    </td><td align="center"> 21       </td></tr>
<tr><td> Red LED   </td><td align="center"> 25       </td></tr>
<tr><td> Amber LED </td><td align="center"> 8        </td></tr>
<tr><td> Green LED </td><td align="center"> 7        </td></tr>
<tr><td> Buzzer    </td><td align="center"> 15       </td></tr>
</tbody></table>
<a class="header" href="print.html#dive-into-python" id="dive-into-python"><h3>Dive into Python</h3></a>
<p>Open the Python application IDLE and get started by testing out the button.</p>
<ul>
<li>
<p>Open <strong>Python 3</strong> from the main menu:</p>
<p><img src="images/python3-app-menu.png" alt="Python 3" /></p>
</li>
<li>
<p>Create a new file by clicking <strong>File</strong> &gt; <strong>New File</strong>. This will open up a second window.</p>
</li>
<li>
<p>Save the new file straight away by clicking <strong>File</strong> &gt; <strong>Save</strong>; name the file <code>trafficlights.py</code> and save it in your home folder.</p>
</li>
<li>
<p>Enter the following code:</p>
<pre><code class="language-python">from gpiozero import Button

button = Button(21)

while True:
    print(button.is_pressed)
</code></pre>
<p>In GPIO Zero, you create an object for each component used. Each component interface must be imported from the <code>gpiozero</code> module, and an instance created on the GPIO pin number to which it is connected.</p>
</li>
<li>
<p>Save and run the code by pressing <code>Ctrl + S</code> and <code>F5</code>.</p>
</li>
<li>
<p>This will bring the original Python window into focus and will be constantly printing <code>False</code>. When you press the button this will switch to <code>True</code>, and when you let go it will return to <code>False</code>.</p>
<p><code>button.is_pressed</code> is a property of the <code>button</code> object, which provides the state of the button (pressed or not) at any given time.</p>
</li>
<li>
<p>Now return to the code window and modify your <code>while</code> loop to show the following:</p>
<pre><code class="language-python">while True:
    if button.is_pressed:
        print(&quot;Hello&quot;)
    else:
        print(&quot;Goodbye&quot;)
</code></pre>
</li>
<li>
<p>Run the code again and you'll see &quot;Hello&quot; printed when the button is pressed, and &quot;Goodbye&quot; when the button is not pressed.</p>
</li>
<li>
<p>Modify the loop again:</p>
<pre><code class="language-python">while True:
    button.wait_for_press()
    print(&quot;Pressed&quot;)
    button.wait_for_release()
    print(&quot;Released&quot;)
</code></pre>
</li>
<li>
<p>When you run the code this time, nothing will happen until you press the button, when you'll see &quot;Pressed&quot;, then when you let go you'll see &quot;Released&quot;. This will occur each time the button is pressed, but rather than continuously printing one or the other, it only does it once per press.</p>
</li>
</ul>
<a class="header" href="print.html#add-an-led" id="add-an-led"><h3>Add an LED</h3></a>
<p>Now you'll add an LED into the code and use GPIO Zero to allow the button to determine when the LED is lit.</p>
<ul>
<li>
<p>In your code, add to the <code>from gpiozero import...</code> line at the top to also bring in <code>LED</code>:</p>
<pre><code class="language-python">from gpiozero import Button, LED
</code></pre>
</li>
<li>
<p>Add a line below <code>button = Button(21)</code> to create an instance of an <code>LED</code> object:</p>
<pre><code class="language-python">led = LED(25)
</code></pre>
</li>
<li>
<p>Now modify your <code>while</code> loop to turn the LED on when the button is pressed:</p>
<pre><code class="language-python">while True:
    button.wait_for_press()
    led.on()
    button.wait_for_release()
    led.off()
</code></pre>
</li>
<li>
<p>Run your code and the LED will come on when you press the button. Hold the button down to keep the LED lit.</p>
</li>
<li>
<p>Now swap the <code>on</code> and <code>off</code> lines to reverse the logic:</p>
<pre><code class="language-python">while True:
    led.on()
    button.wait_for_press()
    led.off()
    button.wait_for_release()
</code></pre>
</li>
<li>
<p>Run the code and you'll see the LED stays on until the button is pressed.</p>
</li>
<li>
<p>Now replace <code>led.on()</code> with <code>led.blink()</code>:</p>
<pre><code class="language-python">while True:
    led.blink()
    button.wait_for_press()
    led.off()
    button.wait_for_release()
</code></pre>
</li>
<li>
<p>Run the code and you'll see the LED blink on and off until the button is pressed, at which point it will turn off completely. When the button is released, it will start blinking again.</p>
</li>
<li>
<p>Try adding some parameters to <code>blink</code> to make it blink faster or slower:</p>
<ul>
<li><code>led.blink(2, 2)</code> - 2 seconds on, 2 seconds off</li>
<li><code>led.blink(0.5, 0.5)</code> - half a second on, half a second off</li>
<li><code>led.blink(0.1, 0.2)</code> - one tenth of a second on, one fifth of a second off</li>
</ul>
<p><code>blink</code>'s first two (optional) parameters are <code>on_time</code> and <code>off_time</code>': they both default to 1 second.</p>
</li>
</ul>
<a class="header" href="print.html#traffic-lights" id="traffic-lights"><h3>Traffic lights</h3></a>
<p>You have three LEDs: red, amber, and green. Perfect for traffic lights! There's even a built-in interface for traffic lights in GPIO Zero.</p>
<ul>
<li>
<p>Amend the <code>from gpiozero import...</code> line to replace <code>LED</code> with <code>TrafficLights</code>:</p>
<pre><code class="language-python">from gpiozero import Button, TrafficLights
</code></pre>
</li>
<li>
<p>Replace your <code>led = LED(25)</code> line with the following:</p>
<pre><code class="language-python">lights = TrafficLights(25, 8, 7)
</code></pre>
<p>The <code>TrafficLights</code> interface takes three GPIO pin numbers, one for each pin: red, amber, and green (in that order).</p>
</li>
<li>
<p>Now amend your <code>while</code> loop to control the <code>TrafficLights</code> object:</p>
<pre><code class="language-python">while True:
    button.wait_for_press()
    lights.on()
    button.wait_for_release()
    lights.off()
</code></pre>
<p>The <code>TrafficLights</code> interface is very similar to that of an individual LED: you can use <code>on</code>, <code>off</code>, and <code>blink</code>, all of which control all three lights at once.</p>
</li>
<li>
<p>Try the <code>blink</code> example:</p>
<pre><code class="language-python">while True:
    lights.blink()
    button.wait_for_press()
    lights.off()
    button.wait_for_release()
</code></pre>
</li>
</ul>
<a class="header" href="print.html#add-a-buzzer" id="add-a-buzzer"><h3>Add a buzzer</h3></a>
<p>Now you'll add your buzzer to make some noise.</p>
<ul>
<li>
<p>Add <code>Buzzer</code> to the <code>from gpiozero import...</code> line:</p>
<pre><code class="language-python">from gpiozero import Button, TrafficLights, Buzzer
</code></pre>
</li>
<li>
<p>Add a line below your creation of <code>button</code> and <code>lights</code> to add a <code>Buzzer</code> object:</p>
<pre><code class="language-python">buzzer = Buzzer(15)
</code></pre>
</li>
<li>
<p><code>Buzzer</code> works exactly like <code>LED</code>, so try adding a <code>buzzer.on()</code> and <code>buzzer.off()</code> into your loop:</p>
<pre><code class="language-python">while True:
    lights.on()
    buzzer.off()
    button.wait_for_press()
    lights.off()
    buzzer.on()
    button.wait_for_release()
</code></pre>
</li>
<li>
<p><code>Buzzer</code> has a <code>beep()</code> method which works like <code>LED</code>'s <code>blink</code>. Try it out:</p>
<pre><code class="language-python">while True:
    lights.blink()
    buzzer.beep()
    button.wait_for_press()
    lights.off()
    buzzer.off()
    button.wait_for_release()
</code></pre>
</li>
</ul>
<a class="header" href="print.html#traffic-lights-sequence" id="traffic-lights-sequence"><h3>Traffic lights sequence</h3></a>
<p>As well as controlling the whole set of lights together, you can also control each LED individually. With traffic light LEDs, a button and a buzzer, you can create your own traffic lights sequence, complete with pedestrian crossing!</p>
<ul>
<li>
<p>At the top of your file, below <code>from gpiozero import...</code>, add a line to import the <code>sleep</code> function:</p>
<pre><code class="language-python">from time import sleep
</code></pre>
</li>
<li>
<p>Modify your loop to perform an automated sequence of LEDs being lit:</p>
<pre><code class="language-python">while True:
    lights.green.on()
    sleep(1)
    lights.amber.on()
    sleep(1)
    lights.red.on()
    sleep(1)
    lights.off()
</code></pre>
</li>
<li>
<p>Add a <code>wait_for_press</code> so that pressing the button initiates the sequence:</p>
<pre><code class="language-python">while True:
    button.wait_for_press()
    lights.green.on()
    sleep(1)
    lights.amber.on()
    sleep(1)
    lights.red.on()
    sleep(1)
    lights.off()
</code></pre>
<p>Try some more sequences of your own.</p>
</li>
<li>
<p>Now try creating the full traffic lights sequence:</p>
<ul>
<li>Green on</li>
<li>Amber on</li>
<li>Red on</li>
<li>Red and amber on</li>
<li>Green on</li>
</ul>
<p>Be sure to turn the correct lights on and off at the right time, and make sure you use <code>sleep</code> to time the sequence perfectly.</p>
</li>
<li>
<p>Try adding the button for a pedestrian crossing. The button should move the lights to red (not immediately), and give the pedestrians time to cross before moving back to green until the button is pressed again.</p>
</li>
<li>
<p>Now try adding a buzzer to beep quickly to indicate that it is safe to cross, for the benefit of visually impaired pedestrians.</p>
</li>
</ul>
<a class="header" href="print.html#using-a-light-dependent-resistor" id="using-a-light-dependent-resistor"><h2>Using a light-dependent resistor</h2></a>
<a class="header" href="print.html#analogue-inputs" id="analogue-inputs"><h3>Analogue inputs</h3></a>
<p>In the world of electrical engineering, there are two type of input and output (I/O): analogue and digital. Digital I/O is fairly easy to understand; it's either <em>on</em> or <em>off</em>, <em>1</em> or <em>0</em>.</p>
<p>When talking about voltages and the Raspberry Pi, any input that is approximately below 1.8V is considered <em>off</em> and anything above 1.8V is considered <em>on</em>. For output, 0V is off and 3.3V is on.</p>
<p>Analogue I/O is a little trickier. With an analogue input, we can have a range of voltages from 0V up to 3.3V, and the Raspberry Pi is unable to detect exactly what that voltage is.</p>
<p><img src="images/analogue-digital.png" alt="" /></p>
<p>How, then, can we use a Raspberry Pi to determine the value of an analogue input, if it can only tell when the voltage to a GPIO pin goes above 1.8V?</p>
<a class="header" href="print.html#using-a-capacitor-for-analogue-inputs" id="using-a-capacitor-for-analogue-inputs"><h3>Using a capacitor for analogue inputs</h3></a>
<p>Capacitors are electrical components that store charge.</p>
<p><img src="images/capacitor.png" alt="" /></p>
<p>When current is fed into a capacitor, it will begin to store charge. The voltage across the capacitor will start off low, and increase as the charge builds up.</p>
<p>By putting a resistor in series with the capacitor, you can slow the speed at which it charges. With a high resistance, the capacitor will charge slowly, whereas a low resistance will let it charge quickly.</p>
<p>If you time how long it takes the capacitor's voltage to get over 1.8V (or be <em>on</em>), you can work out the resistance of the component in series with it.</p>
<a class="header" href="print.html#light-dependent-resistors" id="light-dependent-resistors"><h3>Light-dependent resistors</h3></a>
<p>An LDR (sometimes called a photocell) is a special type of resistor.</p>
<p><img src="images/ldr.png" alt="" /></p>
<p>When light hits the LDR, its resistance is very low, but when it's in the dark its resistance is very high.</p>
<p>By placing a capacitor in series with an LDR, the capacitor will charge at different speeds depending on whether it's light or dark.</p>
<a class="header" href="print.html#creating-a-light-sensing-circuit" id="creating-a-light-sensing-circuit"><h3>Creating a light-sensing circuit</h3></a>
<ul>
<li>Place an LDR into your breadboard, as shown below:</li>
</ul>
<p><img src="images/Laser-tripwire_1-01.png" alt="" /></p>
<ul>
<li>Now place a capacitor in series with the LDR. As the capacitor is a polar component, you must make sure the long leg is on the same track as the LDR leg.</li>
</ul>
<p><img src="images/Laser-tripwire_2-01.png" alt="" /></p>
<ul>
<li>Finally, add jumper leads to connect the two components to your Raspberry Pi.</li>
</ul>
<p><img src="images/Laser-tripwire_3-01.png" alt="" /></p>
<a class="header" href="print.html#coding-a-light-sensor" id="coding-a-light-sensor"><h3>Coding a light sensor</h3></a>
<p>Luckily, most of the complicated code you would have to write to detect the light levels received by the LDR has been abstracted away by the <code>gpiozero</code> library. This library will handle the timing of the capacitor's charging and discharging for you.</p>
<p>Use the following code to set up the light sensor:</p>
<pre><code class="language-python">  from gpiozero import LightSensor, Buzzer

  ldr = LightSensor(4)  # alter if using a different pin
  while True:
      print(ldr.value)

</code></pre>
<p>Run this code, then cover the LDR with your hand and watch the value change. Try shining a strong light onto the LDR.</p>
<a class="header" href="print.html#using-a-pir-sensor" id="using-a-pir-sensor"><h2>Using a PIR sensor</h2></a>
<p>Humans and other animals emit radiation all the time. This is nothing to be concerned about, though, as the type of radiation we emit is infrared radiation (IR), which is pretty harmless at the levels at which it is emitted by humans. In fact, all objects at temperatures above absolute zero (-273.15C) emit infrared radiation.</p>
<p>A PIR sensor detects changes in the amount of infrared radiation it receives. When there is a significant change in the amount of infrared radiation it detects, then a pulse is triggered. This means that a PIR sensor can detect when a human (or any animal) moves in front of it.</p>
<p><img src="images/pir_module.png" alt="pir" /></p>
<a class="header" href="print.html#wiring-a-pir-sensor" id="wiring-a-pir-sensor"><h3>Wiring a PIR sensor</h3></a>
<p>The pulse emitted when a PIR detects motion needs to be amplified, and so it needs to be powered. There are three pins on the PIR: they should be labelled <strong>Vcc</strong>, <strong>Gnd</strong>, and <strong>Out</strong>. These labels are sometimes concealed beneath the Fresnel lens (the white cap), which you can temporarily remove to see the pin labels.</p>
<p><img src="images/pir_wiring.png" alt="wiring" /></p>
<ol>
<li>As shown above, the <strong>Vcc</strong> pin needs to be attached to a <strong>5V</strong> pin on the Raspberry Pi.</li>
<li>The <strong>Gnd</strong> pin on the PIR sensor can be attached to <strong>any</strong> ground pin on the Raspberry Pi.</li>
<li>Lastly, the <strong>Out</strong> pin needs to be connected to <strong>any</strong> of the GPIO pins.</li>
</ol>
<a class="header" href="print.html#tuning-a-pir" id="tuning-a-pir"><h3>Tuning a PIR</h3></a>
<p>Most PIR sensors have two potentiometers on them. These can control the sensitivity of the sensors, and also the period of time for which the PIR will signal when motion is detected.</p>
<p><img src="images/pir_pots.jpg" alt="pir pots" /></p>
<p>In the image above, the potentiometer on the right controls the sensitivity, and the potentiometer on the left controls the timeout. Here, both are turned fully anti-clockwise, meaning that the sensitivity and timeout are at their lowest.</p>
<p>When the timeout is turned fully anti-clockwise, the PIR will output a signal for about 2.5 seconds, whenever motion is detected. If the potentiometer is turned fully clockwise, the output signal will last for around 250 seconds. When tuning the sensitivity, it is best to have the timeout set as low as possible.</p>
<a class="header" href="print.html#detecting-motion" id="detecting-motion"><h3>Detecting motion</h3></a>
<p>You can detect motion with the PIR using the code below:</p>
<pre><code class="language-python">from gpiozero import MotionSensor

pir = MotionSensor(4)

while True:
    pir.wait_for_motion()
    print(&quot;You moved&quot;)
    pir.wait_for_no_motion()
</code></pre>
<a class="header" href="print.html#using-an-ultrasonic-distance-sensor" id="using-an-ultrasonic-distance-sensor"><h2>Using an ultrasonic distance sensor</h2></a>
<p>In air, sound travels at a speed of 343 metres per second. An ultrasonic distance sensor sends out pulses of ultrasound which are inaudible to humans, and detects the echo that is sent back when the sound bounces off a nearby object. It then uses the speed of sound to calculate the distance from the object.</p>
<p><img src="images/ultrasonic-distance-sensor.png" alt="Ultrasonic distance sensor" /></p>
<a class="header" href="print.html#wiring-1" id="wiring-1"><h3>Wiring</h3></a>
<p>The circuit connects to two GPIO pins (one for echo, one for trigger), the ground pin, and a 5V pin. You'll need to use a pair of resistors (330Ω and 470Ω) as a potential divider:</p>
<p><img src="images/wiring-uds.png" alt="wiring" /></p>
<a class="header" href="print.html#code" id="code"><h3>Code</h3></a>
<p>To use the ultrasonic distance sensor in Python, you need to know which GPIO pins the echo and trigger are connected to.</p>
<ul>
<li>
<p>Open Python 3.</p>
</li>
<li>
<p>In the shell, enter the following line to import <code>DistanceSensor</code> from the GPIO Zero library:</p>
<pre><code class="language-python">from gpiozero import DistanceSensor
</code></pre>
<p>After each line, press <strong>Enter</strong> and the command will be executed immediately.</p>
</li>
<li>
<p>Create an instance of <code>DistanceSensor</code> using your echo and trigger pins:</p>
<pre><code class="language-python">ultrasonic = DistanceSensor(echo=17, trigger=4)
</code></pre>
</li>
<li>
<p>See what distance it shows:</p>
<pre><code class="language-python">ultrasonic.distance
</code></pre>
<p>You should see a number: this is the distance to the nearest object, in metres.</p>
</li>
<li>
<p>Try using a loop to print the distance continuously, while waving your hand in front of the sensor to alter the distance reading:</p>
<pre><code class="language-python">while True:
    print(ultrasonic.distance)
</code></pre>
<p>The value should get smaller the closer your hand is to the sensor. Press <strong>Ctrl + C</strong> to exit the loop.</p>
</li>
</ul>
<a class="header" href="print.html#ranges" id="ranges"><h3>Ranges</h3></a>
<p>As well as being able to see the distance value, you can also get the sensor to do things when the object is in or out of a certain range.</p>
<ul>
<li>
<p>Use a loop to print different messages when the sensor is in range or out of range:</p>
<pre><code class="language-python">while True:
    ultrasonic.wait_for_in_range()
    print(&quot;In range&quot;)
    ultrasonic.wait_for_out_of_range()
    print(&quot;Out of range&quot;)
</code></pre>
<p>Now wave your hand in front of the sensor; it should switch between showing the message &quot;In range&quot; and &quot;Out of range&quot; as your hand gets closer and further away from the sensor. See if you can work out the point at which it changes.</p>
</li>
<li>
<p>The default range threshold is 0.3m. This can be configured when the sensor is initiated:</p>
<pre><code class="language-python">ultrasonic = DistanceSensor(echo=17, trigger=4, threshold_distance=0.5)
</code></pre>
<p>Alternatively, this can be changed after the sensor is created, by setting the <code>threshold_distance</code> property:</p>
<pre><code class="language-python">ultrasonic.threshold_distance = 0.5
</code></pre>
</li>
<li>
<p>Try the previous loop again and observe the new range threshold.</p>
</li>
<li>
<p>The <code>wait_for</code> functions are <strong>blocking</strong>, which means they halt the program until they are triggered. Another way of doing something when the sensor goes in and out of range is to use <code>when</code> properties, which can be used to trigger actions in the background while other things are happening in the code.</p>
<p>First, you need to create a function for what you want to happen when the sensor is in range:</p>
<pre><code class="language-python">def hello():
    print(&quot;Hello&quot;)
</code></pre>
<p>Then set <code>ultrasonic.when_in_range</code> to the name of this function:</p>
<pre><code class="language-python">ultrasonic.when_in_range = hello
</code></pre>
</li>
<li>
<p>Add another function for when the sensor goes out of range:</p>
<pre><code class="language-python">def bye():
    print(&quot;Bye&quot;)

ultrasonic.when_out_of_range = bye
</code></pre>
<p>Now these triggers are set up, you'll see &quot;hello&quot; printed when your hand is in range, and &quot;bye&quot; when it's out of range.</p>
</li>
<li>
<p>You may have noticed that the sensor distance stopped at 1 metre. This is the default maximum and can also be configured on setup:</p>
<pre><code class="language-python">ultrasonic = DistanceSensor(echo=17, trigger=4, max_distance=2)
</code></pre>
<p>Or after setup:</p>
<pre><code class="language-python">ultrasonic.max_distance = 2
</code></pre>
</li>
<li>
<p>Try different values of <code>max_distance</code> and <code>threshold_distance</code>.</p>
</li>
</ul>
<a class="header" href="print.html#analogue-inputs-1" id="analogue-inputs-1"><h2>Analogue inputs</h2></a>
<p>The Raspberry Pi's GPIO pins are digital pins, so you can only set outputs to high or low, or read inputs as high or low. However, using an ADC chip (Analogue-to-Digital converter), you can read the value of analogue input devices such as potentiometers.</p>
<a class="header" href="print.html#spi" id="spi"><h3>SPI</h3></a>
<p>The analogue values are communicated to the Pi using the SPI protocol. While this will work in GPIO Zero out of the box, you may get better results if you enable full SPI support.</p>
<ul>
<li>
<p>Open a terminal window and install the <code>spidev</code> package:</p>
<pre><code class="language-bash">sudo apt-get install python3-spidev python-spidev
</code></pre>
</li>
<li>
<p>Open the <strong>Raspberry Pi Configuration</strong> dialogue from the main menu and enable <strong>SPI</strong> in the <strong>Interfaces</strong> tab:</p>
<p><img src="images/rcgui.png" alt="Enable SPI" /></p>
</li>
<li>
<p>Click <strong>OK</strong> and reboot the Pi.</p>
</li>
</ul>
<a class="header" href="print.html#wiring-the-adc-mcp3008" id="wiring-the-adc-mcp3008"><h3>Wiring the ADC (MCP3008)</h3></a>
<p>The MCP3008 is an ADC providing eight input channels. The eight connectors on one side are connected to the Pi's GPIO pins, and the other eight are available to connect analogue input devices to read their values.</p>
<p>Place the MCP3008 chip on a breadboard and carefully wire it up as shown in the following diagram. You should see a small notch, or dot, in one end of the chip. In the diagram, this end of the chip is alligned with column <strong>19</strong> on the breadboard.</p>
<p><img src="images/mcp3008.png" alt="MCP3008 wiring" /></p>
<p>Alternatively, you could use the <a href="http://rasp.io/analogzero/">Analog Zero</a> board, which provides the MCP3008 chip on a handy add-on board to save you from the complicated wiring.</p>
<a class="header" href="print.html#add-a-potentiometer" id="add-a-potentiometer"><h3>Add a potentiometer</h3></a>
<p>Now that the ADC is connected to the Pi, you can wire devices up to the input channels. A potentiometer is a good example of an analogue input device: it's simply a variable resistor, and the Pi reads the voltage (from 0V to 3.3V).</p>
<p><img src="images/potentiometer.jpg" alt="Potentiometer" /></p>
<p>A potentiometer's pins are ground, data, and 3V3. This means you connect it to ground and a supply of 3V3, and read the actual voltage from the middle pin.</p>
<ul>
<li>
<p>Place a potentiometer on the breadboard and wire one side to the ground rail, the other to the 3V3 rail, and the middle pin to the first input channel as shown:</p>
<p><img src="images/mcp3008-pot.png" alt="Add a potentiometer" /></p>
</li>
</ul>
<a class="header" href="print.html#code-1" id="code-1"><h3>Code</h3></a>
<p>Now your potentiometer is connected and its value can be read from Python!</p>
<ul>
<li>
<p>Open <strong>Python 3</strong> from the main menu.</p>
</li>
<li>
<p>In the shell, start by importing the <code>MCP3008</code> class from the GPIO Zero library:</p>
<pre><code class="language-python">from gpiozero import MCP3008
</code></pre>
</li>
<li>
<p>Create an object representing your analogue device:</p>
<pre><code class="language-python">pot = MCP3008(0)
</code></pre>
<p>Note the <code>0</code> represents the ADC's channel 0. There are 8 channels (0 to 7), and you're using the first one.</p>
</li>
<li>
<p>Try to read its value:</p>
<pre><code class="language-python">print(pot.value)
</code></pre>
<p>You should see a number between 0 and 1. This represents how far the dial is turned.</p>
</li>
<li>
<p>Now read the value in a loop:</p>
<pre><code class="language-python">while True:
    print(pot.value)
</code></pre>
<p>Try twisting the dial around to see the value change.</p>
</li>
</ul>
<a class="header" href="print.html#pwmled" id="pwmled"><h3>PWMLED</h3></a>
<p>Now you've tested you can read values from the potentiometer, you should connect it to another GPIO device.</p>
<ul>
<li>
<p>Add an LED to your breadboard and wire it to the Pi, connecting it to GPIO pin 21:</p>
<p><img src="images/mcp3008-pot-led.png" alt="Add LED" /></p>
</li>
<li>
<p>In your Python code, start by importing the <code>PWMLED</code> class:</p>
<pre><code class="language-python">from gpiozero import PWMLED
</code></pre>
<p>The <code>PWMLED</code> class lets you control the brightness of an LED using PWM, or pulse-width modulation.</p>
</li>
<li>
<p>Create a <code>PWMLED</code> object on pin 21:</p>
<pre><code class="language-python">led = PWMLED(21)
</code></pre>
</li>
<li>
<p>Test you can control the LED manually:</p>
<pre><code class="language-python">led.on()  # the led should be lit
led.off()  # the led should go off
led.value = 0.5  # the led should be lit at half brightness
</code></pre>
</li>
<li>
<p>Now connect the LED to the potentiometer:</p>
<pre><code class="language-python">led.source = pot.values
</code></pre>
</li>
<li>
<p>Turn the dial to change the LED brightness!</p>
</li>
</ul>
<a class="header" href="print.html#source-and-values" id="source-and-values"><h3>Source and values</h3></a>
<p>GPIO Zero has a powerful feature: <strong>source and values</strong>. Every device has a <code>value</code> property (the current value) and a <code>values</code> property (a stream of the device's values at all times). Every output device has a <code>source</code> property which can be used to set what the device's value should be.</p>
<ul>
<li><code>pot.value</code> gives the potentiometer's current value (it's read only, as it's an input device)</li>
<li><code>led.value</code> is the LED's current value (it's read/write: you can see what it is, and you can change it)</li>
<li><code>pot.values</code> is a generator constantly yielding the potentiometer's current value</li>
<li><code>led.source</code> is a way of setting where the LED gets its values from</li>
</ul>
<p>Rather than continuously setting the value of the LED to the value of the potentiometer in a loop, you can just pair the two devices. Therefore the line <code>led.source = pot.values</code> is equivalent to the following loop:</p>
<pre><code class="language-python">while True:
    led.value = pot.value
</code></pre>
<a class="header" href="print.html#multiple-potentiometers" id="multiple-potentiometers"><h3>Multiple potentiometers</h3></a>
<ul>
<li>
<p>Add a second potentiometer to your breadboard and connect it to the ADC's channel 1:</p>
<p><img src="images/mcp3008-2pots-led.png" alt="Second potentiometer" /></p>
</li>
<li>
<p>Now create a second <code>MCP3008</code> object on channel 1:</p>
<pre><code class="language-python">pot2 = MCP3008(1)
</code></pre>
</li>
<li>
<p>Make the LED blink:</p>
<pre><code class="language-python">led.blink()
</code></pre>
<p>The LED will blink continuously, one second on and one second off.</p>
</li>
<li>
<p>Change the <code>on_time</code> and <code>off_time</code> parameters to make it blink faster or slower:</p>
<pre><code class="language-python">led.blink(on_time=2, off_time=2)
led.blink(on_time=0.5, off_time=0.1)
</code></pre>
</li>
<li>
<p>Now use a loop to change the blink times according to the potentiometer values:</p>
<pre><code class="language-python">while True:
    print(pot.value, pot2.value)
    led.blink(on_time=pot.value, off_time=pot2.value, n=1, background=False)
</code></pre>
<p>Note you have to make it blink once in the foreground, so that each iteration gets time to finish before it updates the blink times.</p>
</li>
<li>
<p>Rotate the dials to make it blink at different speeds!</p>
</li>
<li>
<p>Also try changing <code>blink</code> to <code>pulse</code> and change <code>on_time</code> and <code>off_time</code> to <code>fade_in_time</code> and <code>fade_out_time</code> so that it fades in and out at different speeds, rather than just blinking on and off:</p>
<pre><code class="language-python">while True:
    print(pot.value, pot2.value)
    led.pulse(fade_in_time=pot.value, fade_out_time=pot2.value, n=1, background=False)
</code></pre>
</li>
<li>
<p>Rotate the dials to change the effect.</p>
</li>
</ul>
<a class="header" href="print.html#using-motors" id="using-motors"><h2>Using motors</h2></a>
<p>Motors are great for physical computing: they allow you to turn a wheel forwards and backwards, or make something spin around.</p>
<p>A motor can't be controlled directly from the Raspberry Pi's GPIO pins, because it needs a variable supply of 5 volts. This means you need to power it separately. However, motor controller add-on boards can be used to provide this functionality.</p>
<p>In this guide, you'll be controlling two motors from your Raspberry Pi using Python on the desktop. First, it's best just to learn how to control the motor. Then, once you have it working, you could easily use your code to drive a Raspberry Pi-powered robot by detaching the monitor, mouse, and keyboard and building a robot around a chassis.</p>
<a class="header" href="print.html#h-bridge" id="h-bridge"><h3>H bridge</h3></a>
<p>A motor can be driven forwards or backwards depending on which way around current flows through it. However, it would be awkward to have to rewire a motor, every time you want to change the direction it spins. To overcome this issue, motor controller boards include an H bridge. An H bridge uses 4 transistors to allow digital control of which way current flows through the motor. Most H bridges also contain <em>flyback diodes</em>. A flyback diode prevents the voltage spike that is generated by the motor when it is no longer powered (but still spinning) from damaging delicate electronics.</p>
<p><img src="images/h-bridge.png" alt="H-Bridge" /></p>
<p><em>Image credit: <a href="https://en.wikipedia.org/wiki/H_bridge">Wikipedia</a>, CC BY-SA</em></p>
<a class="header" href="print.html#wiring-2" id="wiring-2"><h3>Wiring</h3></a>
<p>You'll need to wire up two motors and your battery pack using the motor controller.</p>
<ul>
<li>
<p>With your Pi switched off, mount your motor controller board on the GPIO pins:</p>
<p><img src="images/mcb.png" alt="Motor controller board" /></p>
</li>
<li>
<p>Connect a battery pack to the power ports of the motor controller, connecting the positive (red) battery wire to the positive (+) power terminal on the motor controller, and the negative (black) battery wire to the negative (-) power terminal on the motor controller, and connect two motors:</p>
<p><img src="images/mcb-wiring.png" alt="Connect battery pack" /></p>
</li>
<li>
<p>You'll need to know which GPIO pins your motor controller uses. Refer to the board's documentation. This will usually be described as Motor A and Motor B, or MA1, MA2, MB1, and MB2. Make a note of these pin numbers. If you're not sure which is which, you can investigate this next.</p>
</li>
</ul>
<a class="header" href="print.html#output-devices" id="output-devices"><h3>Output devices</h3></a>
<p>First, you should learn to control motors by controlling the pins individually.</p>
<ul>
<li>
<p>Boot the Pi and open Python 3.</p>
</li>
<li>
<p>In the shell, enter the following line to import <code>OutputDevice</code> from the GPIO Zero library:</p>
<pre><code class="language-python">from gpiozero import OutputDevice
</code></pre>
<p>After each line, press <strong>Enter</strong> and the command will be executed immediately.</p>
</li>
<li>
<p>Now create an instance of an <code>OutputDevice</code> on each of the pins for one motor:</p>
<pre><code class="language-python">a = OutputDevice(4)
b = OutputDevice(14)
</code></pre>
</li>
<li>
<p>Now you should be able to make the motor spin by turning one of the pins on:</p>
<pre><code class="language-python">a.on()
</code></pre>
<p>The motor should now be spinning! If not, check you are addressing the right pin numbers. The two pins should be connected to the same motor. Also, check your wiring and your batteries.</p>
</li>
<li>
<p>Now try turning that pin off, and turning the other pin on:</p>
<pre><code class="language-python">a.off()
b.on()
</code></pre>
<p>The motor should now be spinning in the opposite direction.</p>
</li>
<li>
<p>To stop the motor, just make sure both pins are off:</p>
<pre><code class="language-python">a.off()
b.off()
</code></pre>
</li>
<li>
<p>Now try the same with the second motor:</p>
<pre><code class="language-python">c = OutputDevice(17)
d = OutputDevice(27)
c.on()
</code></pre>
</li>
<li>
<p>And backwards:</p>
<pre><code class="language-python">c.off()
d.on()
</code></pre>
</li>
<li>
<p>And stop:</p>
<pre><code class="language-python">c.off()
d.off()
</code></pre>
</li>
<li>
<p>Try controlling one of the motors in a loop:</p>
<pre><code class="language-python">from time import sleep

for i in range(5):
    b.off()
    a.on()
    sleep(5)
    a.off()
    b.on()
    sleep(5)
b.off()
</code></pre>
<p>The motor should now spin forwards for 5 seconds then backwards for 5 seconds, repeat this 5 times, and then stop.</p>
</li>
</ul>
<a class="header" href="print.html#pwm" id="pwm"><h3>PWM</h3></a>
<p>So far, you have used simple on/off commands to control your motors. PWM (pulse-width modulation) allows you to control the speed. The <code>on()</code> function sets the motor to go at full speed, but you can control this to make the motor go at a fraction of this speed.</p>
<ul>
<li>
<p>Since you're going to reuse the same pins in a different way, you'll have to close the connections to the pins. The easiest way to do that is to restart the Python shell by clicking <strong>Shell &gt; Restart shell</strong>.</p>
</li>
<li>
<p>Import the <code>PWMOutputDevice</code> class:</p>
<pre><code class="language-python">from gpiozero import PWMOutputDevice
</code></pre>
</li>
<li>
<p>Create new connections to each of your pins as before, but using <code>PWMOutputDevice</code>:</p>
<pre><code class="language-python">a = PWMOutputDevice(4)
b = PWMOutputDevice(14)
c = PWMOutputDevice(17)
d = PWMOutputDevice(27)
</code></pre>
</li>
<li>
<p>You can still use <code>a.on()</code>, <code>a.off()</code> and so on, but you can also set the device's value to a number between <code>0</code> and <code>1</code>. Try half:</p>
<pre><code class="language-python">a.value = 0.5
</code></pre>
<p>The motor should now be spinning at half speed.</p>
</li>
<li>
<p>To turn the motor in the opposite direction, turn <code>a</code> off (or set its value to <code>0</code>) and set <code>b</code>'s value to <code>0.5</code>:</p>
<pre><code class="language-python">a.value = 0
b.value = 0.5
</code></pre>
<p>The motor should now be spinning backwards at half speed.</p>
</li>
<li>
<p>Try controlling both motors at different speeds to compare:</p>
<pre><code class="language-python">a.value = 0.5
b.value = 0
c.value = 1
d.value = 0
</code></pre>
</li>
<li>
<p>Try increasing the speed in a loop:</p>
<pre><code class="language-python">b.off()
d.off()
for i in range(1, 11):
    speed = i / 10
    print(speed)
    a.value = speed
    c.value = speed
    sleep(0.5)
</code></pre>
<p>The motors should now speed up from 0 (stopped) to 0.1, 0.2 and up to 1.</p>
<p>Be aware, though, that the motor may not move until it gets above a certain speed, as there may not be enough power to engage it.</p>
</li>
</ul>
<a class="header" href="print.html#motor-class" id="motor-class"><h3>Motor class</h3></a>
<p>Now you've learned how setting pins high and low can control a motor, you should proceed to using the built-in <code>Motor</code> class; this has all the functionality you just learned about, provided in a simple way, including PWM for speed.</p>
<ul>
<li>
<p>Restart the shell again (<strong>Ctrl + F6</strong>).</p>
</li>
<li>
<p>Import the <code>Motor</code> class:</p>
<pre><code class="language-python">from gpiozero import Motor
</code></pre>
</li>
<li>
<p>Now create a <code>Motor</code> instance using the pin numbers for each motor:</p>
<pre><code class="language-python">motor1 = Motor(4, 14)
motor2 = Motor(17, 27)
</code></pre>
<p>Note: to make it easier to see which pin is which, you can use <code>Motor(forward=4, backward=14)</code> for future reference.</p>
</li>
<li>
<p>Now drive one of the motors forward using the following code:</p>
<pre><code class="language-python">motor1.forward()
</code></pre>
</li>
<li>
<p>And the other backwards:</p>
<pre><code class="language-python">motor2.backward()
</code></pre>
</li>
<li>
<p>Or try half speed:</p>
<pre><code class="language-python">motor1.forward(0.5)
motor2.backward(0.5)
</code></pre>
</li>
<li>
<p>The <code>Motor</code> class also allows you to reverse the motor's direction. Try using this loop:</p>
<pre><code class="language-python">motor1.forward()
motor2.backward()
while True:
    sleep(5)
    motor1.reverse()
    motor2.reverse()
</code></pre>
<p>This will make the motors spin in opposite directions, then switch every five seconds. Press <strong>Ctrl + C</strong> to exit the loop.</p>
</li>
<li>
<p>Now stop the motors:</p>
<pre><code class="language-python">motor1.stop()
motor2.stop()
</code></pre>
</li>
</ul>
<a class="header" href="print.html#robot-class" id="robot-class"><h3>Robot class</h3></a>
<p>If you had a robot with two wheels you would want to control the two motors together, rather than separately, just like you did for the two pins of each motor. Luckily, there's also a <code>Robot</code> class in GPIO Zero.</p>
<ul>
<li>
<p>Restart the shell again (<strong>Ctrl + F6</strong>).</p>
</li>
<li>
<p>Import the <code>Robot</code> class:</p>
<pre><code class="language-python">from gpiozero import Robot
</code></pre>
</li>
<li>
<p>Now create a <code>Robot</code> instance using the pin numbers for each motor:</p>
<pre><code class="language-python">robot = Robot((4, 14), (17, 27))
</code></pre>
<p>Note: to make it easier to see which pin is which, you can use <code>Robot(left=(4, 14), right=(17, 27))</code> for future reference.</p>
</li>
<li>
<p>Now drive one of the motors forward using the following code:</p>
<pre><code class="language-python">robot.forward()
</code></pre>
<p>Both motors should now be driving forwards.</p>
</li>
<li>
<p>And backwards:</p>
<pre><code class="language-python">robot.backward()
</code></pre>
<p>Both motors should now be driving backwards.</p>
</li>
<li>
<p>Try reverse a few times:</p>
<pre><code class="language-python">robot.reverse()
robot.reverse()
robot.reverse()
</code></pre>
</li>
<li>
<p>Or try half speed:</p>
<pre><code class="language-python">robot.forward(0.5)
</code></pre>
</li>
<li>
<p>That's not all! What would happen if the left wheel went forwards and the right wheel went backwards? The robot would turn right. Try it:</p>
<pre><code class="language-python">robot.right()
</code></pre>
</li>
<li>
<p>Then try this:</p>
<pre><code class="language-python">robot.left()
</code></pre>
</li>
<li>
<p>Now stop the robot:</p>
<pre><code class="language-python">robot.stop()
</code></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
